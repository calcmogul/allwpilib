From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tyler Veness <calcmogul@gmail.com>
Date: Sun, 16 Jun 2024 12:08:49 -0700
Subject: [PATCH 2/9] Use wpi::SmallVector

---
 include/sleipnir/autodiff/expression.hpp      | 4 ++--
 include/sleipnir/autodiff/variable.hpp        | 4 ++--
 include/sleipnir/autodiff/variable_matrix.hpp | 4 ++--
 3 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/include/sleipnir/autodiff/expression.hpp b/include/sleipnir/autodiff/expression.hpp
index 76f6d4ed534ce685194ad7fc62d9b62eb2ca1096..10e20f5e2fb0d7459fcecac2f8ba1bdcc98efc3f 100644
--- a/include/sleipnir/autodiff/expression.hpp
+++ b/include/sleipnir/autodiff/expression.hpp
@@ -34,7 +34,7 @@ struct Expression;
 template <typename Scalar>
 constexpr void inc_ref_count(Expression<Scalar>* expr);
 template <typename Scalar>
-constexpr void dec_ref_count(Expression<Scalar>* expr);
+void dec_ref_count(Expression<Scalar>* expr);
 
 /// Typedef for intrusive shared pointer to Expression.
 ///
@@ -736,7 +736,7 @@ constexpr void inc_ref_count(Expression<Scalar>* expr) {
 /// @tparam Scalar Scalar type.
 /// @param expr The shared pointer's managed object.
 template <typename Scalar>
-constexpr void dec_ref_count(Expression<Scalar>* expr) {
+void dec_ref_count(Expression<Scalar>* expr) {
   // If a deeply nested tree is being deallocated all at once, calling the
   // Expression destructor when expr's refcount reaches zero can cause a stack
   // overflow. Instead, we iterate over its children to decrement their
diff --git a/include/sleipnir/autodiff/variable.hpp b/include/sleipnir/autodiff/variable.hpp
index 910ebcf5266bdf76711db7849dd6584549094e3b..3c4f67c1f6224226620e2ffcc597336435943ce8 100644
--- a/include/sleipnir/autodiff/variable.hpp
+++ b/include/sleipnir/autodiff/variable.hpp
@@ -53,7 +53,7 @@ class Variable : public SleipnirBase {
   Variable() = default;
 
   /// Constructs an empty Variable.
-  explicit constexpr Variable(std::nullptr_t) : expr{nullptr} {}
+  explicit Variable(std::nullptr_t) : expr{nullptr} {}
 
   /// Constructs a Variable from a scalar type.
   ///
@@ -96,7 +96,7 @@ class Variable : public SleipnirBase {
   /// Constructs a Variable pointing to the specified expression.
   ///
   /// @param expr The autodiff variable.
-  explicit constexpr Variable(detail::ExpressionPtr<Scalar>&& expr)
+  explicit Variable(detail::ExpressionPtr<Scalar>&& expr)
       : expr{std::move(expr)} {}
 
   /// Assignment operator for scalar.
diff --git a/include/sleipnir/autodiff/variable_matrix.hpp b/include/sleipnir/autodiff/variable_matrix.hpp
index 9f3b9899ca8162b2da619d1e4e3f79f8fa787a1f..abf7551faca0320f498428b5fbc3efd36e442132 100644
--- a/include/sleipnir/autodiff/variable_matrix.hpp
+++ b/include/sleipnir/autodiff/variable_matrix.hpp
@@ -1134,12 +1134,12 @@ class VariableMatrix : public SleipnirBase {
   /// Returns const begin iterator.
   ///
   /// @return Const begin iterator.
-  const_iterator cbegin() const { return const_iterator{m_storage.cbegin()}; }
+  const_iterator cbegin() const { return const_iterator{m_storage.begin()}; }
 
   /// Returns const end iterator.
   ///
   /// @return Const end iterator.
-  const_iterator cend() const { return const_iterator{m_storage.cend()}; }
+  const_iterator cend() const { return const_iterator{m_storage.end()}; }
 
   /// Returns reverse begin iterator.
   ///
